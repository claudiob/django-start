Setting up the system
=====================

Install required software
-------------------------

First install [brew], a package manager for OS X, by running:

    /usr/bin/ruby -e "$(curl -fsSL https://raw.github.com/gist/323731)"

Now, using brew, install [Python 2.7] by running:

    brew install python

Next, install [pip], the package manager for Python projects:

    sudo easy_install pip
    
Finally, using pip, install [Django 1.3] by running:

    pip install django
    
To confirm that django is installed, you should be able to run the command:

    django-admin.py

As a suggestion, install [Textmate] as a text editor, which allows to edit files from the command line by typing:

    mate
    
Create an empty project with django-admin.py
--------------------------------------------

    mkdir Projects
    cd Projects
    django-admin.py startproject empty
    cd empty
    python manage.py runserver 0.0.0.0:8000
    
Now open http://0.0.0.0:8000 in a browser and you should see this:

    [tut1]
    
And you can see all the files generated by django-admin.py running:

    mate .
    
The next step would be to configure this project. 
However, instead of using this bare installation, we are going to use a template that already contains most of the configuration we commonly apply to projects.
For this purpose we are going to use [django-start] which is a replacement for the `django-admin.py startproject` command.

Creating a project
==================
  
    pip install django-start
    cd ~/Projects
    django-start.py project tutorial
    cd tutorial/project
    ./manage.py server

Probably you will get an error saying that some required packages are not installed.

Install requirements with virtualenv
------------------------------------

As a convention, we list all the requirements for the project inside the deploy/requirements folder, separated by environment.
The file `base.txt` includes packages required in every environment while, for instance, `development.txt` specifies the packages to load only while developing (e.g., profiling tools).
Installing the requirements from a file is as easy as typing `pip install -r deploy/requirements/base.txt`.
However, it's better to install the requirements for a **specific** Django project inside a **specific** folder, rather than in the system.
Creating this *virtual environment* for a Django project is as easy as running:

    cd ..
    pip install virtualenv
    virtualenv env
    source env/bin/activate
    
Now all the requirements will be installed in the virtual environment `env`. Just type:

    cd project
    ./manage.py require
    
which is a shortcut for `pip install -r ../deploy/requirements/base.txt && pip install -r ../deploy/requirements/development.txt`

Now run the server. Instead of writing `python manage.py runserver 0.0.0.0:8000` you can type the shorter
    
    ./manage.py server
    
which is a shortcut introduced by django-admin.py. If you want to make this command even shorter, run `vi ~/.bash_profile` then write:

    # Shortcuts for Django
    alias m="python manage.py"
    alias ms="python manage.py runserver 0.0.0.0:8000"

and reload with `source ~/.bash_profile`. This will give you two shortcuts: `m` and `ms`.

Database and fixtures
---------------------    

Now open http://0.0.0.0:8000/admin in your browser. You will see an error of a missing table.
This happens because we did not create and populate a database, which we can do by running:

    ./manage.py syncdb
    ./manage.py loaddata development

The first command creates the tables corresponding to the models in the application.
Every empty Django application already contain some default models, such as user and groups.

The second command loads all the fixtures called "development" into the database.
In this case, open the newly created project with Texmate, then press ⌘+T and write "dev", you will see one file called development.json.
Then press Control+⌘+R to reveal the file in the project. 
You will see this fixtures belongs to an initial application introduced by the `django-start.py` command with data and commands related to the way in which we manage projects at RED.
This particular fixture creates two objects for administration purpose, a site and a user with username and password `admin`.
In this way you can browse to http://0.0.0.0:8000/admin and log in with admin/admin.

One drawback of Django is the lack for migrations, so one approach is to keep all the data you need just for development in fixtures called `development` and then, every time you need to reset the database, type:

    ./manage.py sync
    
which is another shortcut that resets the database, recreates the tables and repopulates them from the fixtures.
The rule with fixtures is: only those named `initial_data` will always be loaded. In this particular example, we only want an user admin/admin in development so we have the `development` fixture.

Django admin
------------

Finally open http://0.0.0.0:8000/admin in your browser and log in.
If you have already seen the Django admin, you will see some customization here.
First of all, `django-start.py` uses a Django admin extension called [django-grappelli] that improves the look-and-feel of the panels.
Moreover, there are different titles and icons. This is because the whole Django admin interface is just a series of front-end files that can be edited.

Textmate tip: don't include `env` in the folder view: go to Preferences > Advanced > Folder References and add |env| to the Folder pattern.
Now reopen the project in Texmate, press ⌘+T, write "index", click, then press Control+⌘+R.

This is the index view of Django admin, which differs from the Grappelli default in that headers are hidden and apps are alphabetically ordered by model name.
You can edit this file as you want to customize the interface even more. Later we will see how to add an icon when we add a new model to the admin.

Now, just to get used to the admin, edit the *admin* user, and change its password to a stronger one. Tip: use http://strongpasswordgenerator.com/
Now say that we want to keep this strong password for production only. We can save the status of the database to a production fixture. Run:

    ./manage.py dumpdata auth.user sites --indent=4 > apps/ff0000/fixtures/production.json
    
Since the fixture stores the password encrypted, you might want to add it to your documentation, or in the README.md file.
Then you can restore the previous password (admin/admin) for development by typing:

    ./manage.py sync

Creating an app
===============

A Django project is made of different apps (e.g., polls, messages, posts).
We are going to create a blog application. The Django way to create a new app is by running `./manage.py startapp journal`.
This creates a "journal/" folder with four empty files: `__init__.py`, `models.py`, `tests.py`, `views.py`.
However we typically need more files for an app, such as fixtures, templates, default views.

To get a more extended application from scratch, type `rm -rf journal` if you created one, then

    django-start.py app journal

then enter "Post" and (as suggested) add `journal` to INSTALLED_APPS and to urls.py. Then run

    ./manage.py sync
    
and browse to http://0.0.0.0:8000/journal/

Views
-----

The page shows the list of current journal posts and raises some questions:

1. Why does this page look like this?
2. Why is this page accessible at this URL?
3. Why is there already a journal post?

Let's answer one question at the time. Why does the page have this look? 
The look is given by the HTML template used to render this page, which can be found under project/templates/journal/index.html.
By default, django-start.py provides two basic templates to show the list of objects and the detail of a single object.
Edit this HTML file, then reload the page to see the result. For instance, make the list not-numbered.

Apart from the HTML, there is some Django syntax:

* expressions surrounded by {% %} such as conditional expressions and loops
* variables surrounded by {{ }} such as the post title

All the documentation for them is at two pages: https://docs.djangoproject.com/en/1.3/topics/templates/ and https://docs.djangoproject.com/en/1.3/ref/templates/builtins/

For instance, the `date` filter is documented at https://docs.djangoproject.com/en/1.3/ref/templates/builtins/#date and is a built-in filter to format dates.

The most important expressions to remember are `extends` and `block`, which allows for views to be created using partials.
In this case, index.html does not include the entire HTML code, but inherits most of it from "base.html" (extends) and replaces it content with the list of posts (block).
If you open templates/base.html you will find "{% block content %}{% endblock content %}" which is what index.html replaces.
base.html has other placemarks for this to be replaced, such as "<title>{% block pagetitle %}{% endblock pagetitle %}</title>".
To change the title of the journal index page, just add the following to journal/index.html:

  {% block pagetitle %}List of journal posts{% endblock pagetitle %}
  
Important: the {% extend %} call should always remain at the very top of the file.

URLs
----

The next question is: why is this exact HTML file presented when accessing http://0.0.0.0:8000/journal/ ?

All the urls are managed by the `urls.py` file through a series of regular expressions.
For instance this line:

    (r'^$', TemplateView.as_view(template_name='homepage.html')),

means that when nothing is specified after http://0.0.0.0:8000/ then the template to be shows in homepage.html.
The reason why Django looks for this template in the templates/ folder is because this is specified in settings/__init__.py under TEMPLATE_DIRS.
You can use the `TemplateView.as_view` notation if you need to simply spit out an HTML file without passing any model-related data.
Another line in urls.py says:

    (r'^journal/', include('journal.urls')),

This means that every URL starting with http://0.0.0.0:8000/journal/ will be managed by the app/journal/urls.py file.
In this file, you will see the lines:

    urlpatterns = patterns('journal.views',
        (r'^$', 'index', {}, 'posts'),
    
meaning that the exact URL http://0.0.0.0:8000/journal/ will return the result of the function "index" inside the journal.views module.
Open journal/views.py and there you will find the `index` function, which does two things:

1. Retrieve all the published posts
2. Render the journal/index.html template passing the list of posts in the `posts` variable

This explains why http://0.0.0.0:8000/journal/ displays the list of published posts, and also where the `posts` variable in that template comes from.

Models
------

The next question is: why does Post.objects.published() in journal/views.py return one journal post?
Post is defined in journal/models.py as a model with four fields (title, slug, content, published_on) and a manager.
If you check journal/fixtures/development.json you will see a fixture that inserts one post in the database with these four fields, and that was loaded when running ./manage.py sync, which explains why there is a post already.

Another interesting components of the model is the permalink which specifies that a post can be accessed using the *named URL* 'post' and passing the post slug.
Going back to journal/urls.py, there is indeed an URL rule named `post` which accepts a post_slug and returns the result of the show function.
And going back to journal/views.py, the `show` function retrieves a post based on its slug and displays the 'journal/show.html' view passing that post.
Thanks to this rule, we can link each post from the journal/index.html by using the notation:

    {% url post post.slug %}
    
which does not suffer from changes in the location (e.g., if we decide to change http://0.0.0.0:8000/journal/ with http://0.0.0.0:8000/posts/).
Also, the `get_object_or_404` function in journal/views.py makes sure that if you access http://0.0.0.0:8000/journal/something-random then we properly get a 404 error.

To conclude with the journal URLs, journal/urls.py also has a special "posts-feed" rule that invokes PostFeed from journal/feeds.py which, rather than displaying an HTML view, shows an RSS feed.

Admin
-----

Back to http://0.0.0.0:8000/admin/ there is now a new tab to manage Posts. This tab does not have an icon, but we can add one.
If you inspect the source code of the page, you will see that a background-image was specified for `app_auth` (Group and Users) and for `app_sites` (Sites) but not for the newly created `app_journal` (Posts) in http://0.0.0.0:8000/static-local/admin/css/models.css.
In Textmate, press ⌘+T and write "models.css", then Control+⌘+R. Then add this line:

    #app_journal {background-image: url(../img/glyphish/posts.png)}

and add #app_journal to the first selector. django-admin.py already provides a set of icons that you can use, or you can add new one in the folder.
How does Django know that admin-related assets should be loaded from here? Because it's specified in the settings under `ADMIN_MEDIA_PREFIX` and `ADMIN_MEDIA_ROOT`.

Also you may wonder: why is there a `static` folder and a `static-local` folder? The reason is in the way these folders are treated when the site is published on a real server.
The `static-admin` folder will remain on the same server as the rest of the code. The `static` folder, on the other hand, might be moved to a CDN to improve page speed.
Since Django admin is only used by administrator, it does not make sense to host its assets on a CDN.
Also, we can leave in `static-local` all those files that should be served by the same web server, such as favicon.ico or crossdomain.xml, because clients will look for them in the root of the server.

Going on with the admin and clicking on "Posts", here is the "Admin index" view, whose interface can also be customized.
Clicking on a Post brings to the "Admin detail" view. The list of fields shown in this views, together with the ordering, filters, etc. depends on the settings in journal/admin.py.
Also, since we specified a permalink for the Post model, we get for free a "View on site" button in the Admin detail view.

This particular Admin detail includes a tinymce editor whose settings can be changed by editing tinymce_setup.js.
Since this field allows HTML and TinyMCE filters out which tags to use, we have to make sure that journal/show.html has the "safe" filter applied to post.content, in order to show the formatted content.

